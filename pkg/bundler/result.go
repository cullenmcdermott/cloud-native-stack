package bundler

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"time"
)

// BundleResult contains the result of a single bundler execution.
type BundleResult struct {
	// Type is the bundler type that generated this result.
	Type BundleType `json:"type" yaml:"type"`

	// Files is the list of files generated by this bundler.
	Files []string `json:"files" yaml:"files"`

	// Duration is the time taken to generate the bundle.
	Duration time.Duration `json:"duration" yaml:"duration"`

	// Size is the total size in bytes of all generated files.
	Size int64 `json:"size_bytes" yaml:"size_bytes"`

	// Checksum is the SHA256 checksum of the bundle contents.
	Checksum string `json:"checksum" yaml:"checksum"`

	// Errors contains non-fatal errors encountered during generation.
	Errors []string `json:"errors,omitempty" yaml:"errors,omitempty"`

	// Success indicates whether the bundler completed successfully.
	Success bool `json:"success" yaml:"success"`
}

// BundleOutput contains the aggregated results of all bundler executions.
type BundleOutput struct {
	// Results contains individual bundler results.
	Results []*BundleResult `json:"results" yaml:"results"`

	// TotalSize is the total size in bytes of all generated files.
	TotalSize int64 `json:"total_size_bytes" yaml:"total_size_bytes"`

	// TotalFiles is the total count of generated files.
	TotalFiles int `json:"total_files" yaml:"total_files"`

	// TotalDuration is the total time taken for all bundlers.
	TotalDuration time.Duration `json:"total_duration" yaml:"total_duration"`

	// Errors contains errors from failed bundlers.
	Errors []BundleError `json:"errors,omitempty" yaml:"errors,omitempty"`

	// OutputDir is the directory where bundles were generated.
	OutputDir string `json:"output_dir" yaml:"output_dir"`
}

// BundleError represents an error from a specific bundler.
type BundleError struct {
	BundlerType BundleType `json:"bundler_type" yaml:"bundler_type"`
	Error       string     `json:"error" yaml:"error"`
}

// HasErrors returns true if any bundler failed.
func (bo *BundleOutput) HasErrors() bool {
	return len(bo.Errors) > 0
}

// SuccessCount returns the number of successful bundlers.
func (bo *BundleOutput) SuccessCount() int {
	count := 0
	for _, r := range bo.Results {
		if r.Success {
			count++
		}
	}
	return count
}

// FailureCount returns the number of failed bundlers.
func (bo *BundleOutput) FailureCount() int {
	return len(bo.Results) - bo.SuccessCount()
}

// Summary returns a human-readable summary of the bundle generation.
func (bo *BundleOutput) Summary() string {
	return fmt.Sprintf(
		"Generated %d files (%s) in %v. Success: %d/%d bundlers.",
		bo.TotalFiles,
		formatBytes(bo.TotalSize),
		bo.TotalDuration.Round(time.Millisecond),
		bo.SuccessCount(),
		len(bo.Results),
	)
}

// formatBytes formats bytes into human-readable format.
func formatBytes(bytes int64) string {
	const unit = 1024
	if bytes < unit {
		return fmt.Sprintf("%d B", bytes)
	}
	div, exp := int64(unit), 0
	for n := bytes / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])
}

// ComputeChecksum computes SHA256 checksum of file contents.
func ComputeChecksum(contents []byte) string {
	hash := sha256.Sum256(contents)
	return hex.EncodeToString(hash[:])
}

// NewBundleResult creates a new BundleResult with the given type.
func NewBundleResult(bundlerType BundleType) *BundleResult {
	return &BundleResult{
		Type:    bundlerType,
		Files:   make([]string, 0),
		Errors:  make([]string, 0),
		Success: false,
	}
}

// AddFile adds a file to the result and updates size.
func (br *BundleResult) AddFile(path string, size int64) {
	br.Files = append(br.Files, path)
	br.Size += size
}

// AddError adds a non-fatal error to the result.
func (br *BundleResult) AddError(err error) {
	if err != nil {
		br.Errors = append(br.Errors, err.Error())
	}
}

// MarkSuccess marks the bundle generation as successful.
func (br *BundleResult) MarkSuccess() {
	br.Success = true
}
